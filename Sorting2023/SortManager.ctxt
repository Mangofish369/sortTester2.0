#BlueJ class context
comment0.target=SortManager
comment0.text=\r\n\ Write\ a\ description\ of\ class\ SortManager\ here.\r\n\r\n\ @author\ (your\ name)\r\n\ @version\ (a\ version\ number\ or\ a\ date)\r\n
comment1.params=
comment1.target=void\ oldTester()
comment10.params=arr\ begin\ end
comment10.target=int[]\ quickSortOpCount(int[],\ int,\ int)
comment10.text=\r\n\ Quick\ sort\ with\ an\ operation\ counter\r\n\ \r\n\ @param\ arr\ \ \ \ \ \ \ \ \ \ \ Unsorted\ array\ of\ numbers\r\n\ @param\ begin\ \ \ \ \ \ \ \ \ Front\ element\r\n\ @param\ end\ \ \ \ \ \ \ \ \ \ \ Last\ element\r\n\ @return\ int[]\r\n
comment11.params=arr\ begin\ end
comment11.target=int\ partitionOpCount(int[],\ int,\ int)
comment11.text=\r\n\ A\ helper\ method\ for\ quick\ sort\ with\ an\ operation\ counter\r\n\ \r\n\ @param\ begin\ \ \ \ \ \ \ \ \ Front\ element\r\n\ @param\ end\ \ \ \ \ \ \ \ \ \ \ Last\ element\r\n\ @return\ int\r\n
comment12.params=theArray\ report
comment12.target=boolean\ checkResults(int[],\ boolean)
comment12.text=\r\n\ Method\ to\ check\ that\ the\ list\ is\ correctly\ sorted\ in\ ascending\ order\r\n\ \r\n\ @param\ theArray\ \ \ \ \ \ \ \ \ \ The\ array\ being\ tested\r\n\ @boolean\ report\ \ \ \ \ \ \ \ \ \ Check\ if\ results\ should\ be\ printed\r\n\ @return\ boolean\r\n
comment2.params=args
comment2.target=void\ main(java.lang.String[])
comment2.text=\r\n\ \ Main\ loop\ to\ test\ out\ different\ sorting\ algorithms\r\n\ \ \r\n\ \ @param\ args\ \ \ \ \ \ \ \ \ \ \ \ \ Filled\ in\ by\ java\ \r\n
comment3.params=fileName
comment3.target=void\ loadData(java.lang.String)
comment3.text=\r\n\ Method\ to\ load\ file\ containing\ a\ list\ of\ numbers\ and\ input\ them\ into\ an\ array\r\n\ \r\n\ @param\ fileName\ \ \ \ \ \ \ \ \ \ String\ of\ the\ file\r\n
comment4.params=num
comment4.target=int[]\ bubbleSortOpCount(int[])
comment4.text=\r\n\ This\ is\ an\ example\ of\ how\ to\ turn\ a\ sort\ algorithm\r\n\ into\ an\ "opCount"\ method\ -\ it\ uses\ a\ rough\ count\r\n\ of\ overall\ operations\ to\ provide\ some\ interesting\r\n\ information\ -\ it's\ non-scientific,\ but\ when\ you\ compare\r\n\ the\ results\ you\ can\ get\ proportionate\ and\ interesting\r\n\ results.\r\n
comment5.params=num
comment5.target=int[]\ bubbleSort(int[])
comment6.params=array
comment6.target=int[]\ recursionSort(int[])
comment6.text=\r\n\ My\ own\ sort\ method,\ runs\ through\ a\ list,\ each\ time\ it\ detects\ the\ element\ ahead\ to\ be\ smaller\ than\ current\ element\r\n\ it\ will\ switch\ places\ and\ call\ on\ itself\ again.\r\n\ \r\n\ Warning,\ large\ data\ sets\ (1000+\ values)\ will\ cause\ the\ recursive\ method\ to\ stack\ overflow\r\n\ \r\n\ @param\ array\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ The\ unsorted\ array\ of\ numbers\r\n\ @param\ int\ []\r\n
comment7.params=array
comment7.target=int[]\ recursionSortOpCount(int[])
comment7.text=\r\n\ My\ own\ sort\ method\ with\ an\ operation\ counter.\r\n\ \r\n\ Warning,\ large\ data\ sets\ (1000+\ values)\ will\ cause\ the\ recursive\ method\ to\ stack\ overflow\r\n\ \r\n\ @param\ array\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ The\ unsorted\ array\ of\ numbers\r\n\ @return\ int\ []\r\n
comment8.params=arr\ begin\ end
comment8.target=int[]\ quickSort(int[],\ int,\ int)
comment8.text=\r\n\ Quick\ sort\ algorithm\r\n\ \r\n\ @param\ arr\ \ \ \ \ \ \ \ \ \ \ Unsorted\ array\ of\ numbers\r\n\ @param\ begin\ \ \ \ \ \ \ \ \ Front\ element\r\n\ @param\ end\ \ \ \ \ \ \ \ \ \ \ Last\ element\r\n\ @return\ int[]\r\n\ \r\n
comment9.params=arr\ begin\ end
comment9.target=int\ partition(int[],\ int,\ int)
comment9.text=\r\n\ A\ helper\ method\ for\ quick\ sort\ to\ break\ apart\ the\ array\ in\ order\ to\ more\ efficently\ swap\ values\r\n\ \r\n\ @param\ begin\ \ \ \ \ \ \ \ \ Front\ element\r\n\ @param\ end\ \ \ \ \ \ \ \ \ \ \ Last\ element\r\n\ @return\ int\r\n
numComments=13
